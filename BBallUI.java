/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package playoff.predictor;
import java.util.*;
import java.io.*;
import java.sql.Connection;  
import java.sql.DriverManager;  
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.PreparedStatement;
import javax.swing.JOptionPane;

/**
 *
 * @author home
 */
public class BBallUI extends javax.swing.JFrame {

    private Set<String> team_names;
    private HashMap<String, Team> teams = new HashMap<String, Team>();
    private String[] dropdown_headers = new String[18];
    private ArrayList<Team> east_teams = new ArrayList<Team>();
    private ArrayList<Team> west_teams = new ArrayList<Team>();
    private int[] seeds = {1, 8, 4, 5, 3, 6, 2, 7};
    private int fill_tree_index = 0;
    private int round = 0;
    private TreeNode root;
    private List<Team[]> matchups;
    private Connection conn;
    /**
     * Creates new form NewJFrame
     */
    public BBallUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        teamList = new javax.swing.JList<>();
        jScrollPane2 = new javax.swing.JScrollPane();
        playoffGraph = new javax.swing.JTextArea();
        loadTeams = new javax.swing.JButton();
        jComboBox1 = new javax.swing.JComboBox<>();
        sortBy = new javax.swing.JButton();
        playoffPredictions = new javax.swing.JButton();
        clear = new javax.swing.JButton();
        simRound = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Bebas Neue", 0, 48)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("NBA Playoffs Predictor");

        teamList.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(teamList);

        playoffGraph.setColumns(20);
        playoffGraph.setRows(5);
        jScrollPane2.setViewportView(playoffGraph);

        loadTeams.setText("Load Teams");
        loadTeams.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadTeamsActionPerformed(evt);
            }
        });

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { }));

        sortBy.setText("Sort By");
        sortBy.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sortByActionPerformed(evt);
            }
        });

        playoffPredictions.setText("Display Playoff Predictions");
        playoffPredictions.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playoffPredictionsActionPerformed(evt);
            }
        });

        clear.setText("Clear");
        clear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearActionPerformed(evt);
            }
        });

        simRound.setText("Sim Round");
        simRound.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                simRoundActionPerformed(evt);
            }
        });

        jButton1.setText("Add Team");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane2)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(loadTeams)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jButton1)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(playoffPredictions)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(simRound)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(clear)))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(sortBy)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 209, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(loadTeams)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(sortBy)
                    .addComponent(playoffPredictions)
                    .addComponent(clear)
                    .addComponent(simRound)
                    .addComponent(jButton1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 16, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane2)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 255, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void loadTeamsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadTeamsActionPerformed
        // TODO add your handling code here:
        try {
            Scanner sc = new Scanner(new File("/Users/home/NetBeansProjects/Playoff Predictor/src/playoff/predictor/data/advanced.csv"));  
            sc.useDelimiter(",");   //sets the delimiter pattern  
            
            // add headers to drop down
            sc.next(); sc.next();
            for (int i = 0; i < dropdown_headers.length; i++) {
                dropdown_headers[i] = sc.next();
                //if (i == dropdown_headers.length-1) System.out.println(dropdown_headers[i]);
            }
            sc.next();
        } catch (FileNotFoundException e) {
            System.out.println("oopsies");
        }
            /*
            while (sc.hasNextLine())  //returns a boolean value  
            {  
                //System.out.print(sc.next() + " ");  //find and returns the next complete token from this scanner  
                sc.next();
                String team_name = sc.next();
                //System.out.println(team_name);
                sc.next();
                Double[] team_data = new Double[18];
                for (int i = 0; i < team_data.length; i++) {
                    team_data[i] = Double.parseDouble(sc.next());
                    //System.out.print(team_data[i] + ", ");
                }
                //System.out.println(team_data[0] + ", " + team_data[17]);
                //System.out.println();
                                
                Team t = new Team(team_name, team_data);
                teams.put(team_name, t);
                
                if (sc.next().equals("W")) west_teams.add(t);
                else east_teams.add(t);
                t.setConf(east_teams.contains(t));
            }   
            sc.close();  //closes the scanner 
            team_names = teams.keySet();
            
            String[] tn_sub = new String[team_names.size()];
            int i = 0;
            for (String tn : team_names) {
                tn_sub[i++] = tn;
            }
            System.out.println(teams.keySet());
            
            teamList = new javax.swing.JList<>();

            teamList.setModel(new javax.swing.AbstractListModel<String>() {
                String[] strings = tn_sub;
                public int getSize() { return strings.length; }
                public String getElementAt(int i) { return strings[i]; }
            });
            
            jScrollPane1.setViewportView(teamList);
            
            jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(dropdown_headers));
            
        } catch (FileNotFoundException e) {
            System.out.println("oops");
        } */
        try {
            String url = "jdbc:sqlite:/Users/home/NetBeansProjects/Playoff Predictor/src/playoff/predictor/data/team_data.db";
            System.out.println("done");
            conn = DriverManager.getConnection(url);
            System.out.println(conn);
            
            teams = new HashMap<String, Team>();

            String tableName = "advanced";

            String selectSQL = "SELECT * FROM " + tableName;
            System.out.println(selectSQL);
            Statement stmt = conn.createStatement();
            System.out.println(stmt);
            ResultSet rs = stmt.executeQuery(selectSQL);
            System.out.println(rs);

            rs.next();
            while(rs.next()){
                System.out.println("running");
                Double[] data = new Double[18];
                for (int i = 0; i < dropdown_headers.length; i++) {
                    data[i] = rs.getDouble("field"+(i+4));
                }
                Team temp = new Team(rs.getString("field2"), data);
                String key = rs.getString("field2");
                teams.put(key, temp);

                // east west
                if (rs.getString("field22").equals("W")) west_teams.add(temp);
                else east_teams.add(temp);
                temp.setConf(east_teams.contains(temp));
            }
        } catch (SQLException e) {
            System.out.println("error");
        }
        
        team_names = teams.keySet();
            
        String[] tn_sub = new String[team_names.size()];
        int i = 0;
        for (String tn : team_names) {
            tn_sub[i++] = tn;
        }
        System.out.println(teams.keySet());
        
        teamList = new javax.swing.JList<>();

        teamList.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = tn_sub;
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
            
        jScrollPane1.setViewportView(teamList);
            
        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(dropdown_headers));
        
    }//GEN-LAST:event_loadTeamsActionPerformed

    private void sortByActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sortByActionPerformed
        // TODO add your handling code here:
        // get index of the data point
        int index = jComboBox1.getSelectedIndex();
        
        // create a seperate Hash whatever with the data
        double[] data = new double[30];
        int i = 0;
        for (String key : teams.keySet()) {
            data[i++] = teams.get(key).getData()[index];
        }
        
        // sort using heapsort
        sort(data);
        data = reverse(data, data.length);
        /*for (double d : data) {
            System.out.print(d + ", ");
        }*/
        
        // find the team names based on the data
        teamList = new javax.swing.JList<>();
        
        ArrayList<String> team_n_data = new ArrayList<String>();
        i = 0;
        for (double d : data) {
            for (String key : teams.keySet()) {
                if (!team_n_data.contains(key + " - " + d) && d == teams.get(key).getData()[index]) {
                    team_n_data.add(key + " - " + d);
                    break;
                }
            }
        }

        teamList.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = team_n_data.toArray(new String[team_n_data.size()]);
;
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
            
        jScrollPane1.setViewportView(teamList);
        
        
        
    }//GEN-LAST:event_sortByActionPerformed

    private void playoffPredictionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playoffPredictionsActionPerformed
        // TODO add your handling code here:
        // use index of W column product
        int index = 0;
        
        // create a seperate Hash whatever with the data
        double[] data = new double[30];
        int i = 0;
        for (String key : teams.keySet()) {
            data[i++] = teams.get(key).getData()[index];
        }
        
        // sort using heapsort
        sort(data);
        data = reverse(data, data.length);
        
        // split into top 16, seed them against each other
        // West, East
        String[][] playoff_teams = new String[2][8];
        int e = 0;
        int w = 0;
        while (playoff_teams[0][7] == null || playoff_teams[1][7] == null) {
            for (String team_name : team_names) {
                //System.out.println(team_name);
                //System.out.println("east" + playoff_teams[0][7]);
                //System.out.println("west" + playoff_teams[1][7]);
                if (teams.get(team_name).getData()[index] == data[e+w]) {
                    if (teams.get(team_name).isConf()) {
                        if (e <= 7)
                            playoff_teams[0][e++] = team_name;
                        else e++;
                    } else {
                        if (w <= 7)
                            playoff_teams[1][w++] = team_name;
                        else w++;
                    }
                }
            }
        }
        
        root = genNullTree(null, null);
        
        // iterate through the leaves, add the values
        root = addTeamsToBracket(root, playoff_teams, true);
        
        playoffGraph.setText("");
        
        playoffGraph.setText(display(root, 0));
        /*
        int i = 1;
        for (Team t : list) {
            textField.append(i + " - " + t + ", Win-Loss: " + t.getWins() + "-" + (t.getGamesPlayed()-t.getWins()) + "\n");
            i++;
        }
        bst_displayed = false;*/
    }//GEN-LAST:event_playoffPredictionsActionPerformed

    private void clearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearActionPerformed
        // TODO add your handling code here:
        playoffGraph.setText("");
    }//GEN-LAST:event_clearActionPerformed

    private void simRoundActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_simRoundActionPerformed
        // TODO add your handling code here:
        // get the matchups in an array? other data structure?
        round += 1;
        matchups = new ArrayList<Team[]>();
        findMatchups(root, 4-round, 0);
        System.out.println("matchups found");
        
        for (Team[] t : matchups) {
            for (Team t1 : t) {
                System.out.print(t1 + ", ");
            }
            System.out.println();
        }
        
        // iterate through the matchups and get winners
        String[][] winners;
        if (matchups.size() == 1) {
            Game g = new Game(matchups.get(0)[0], matchups.get(0)[1]);
            winners = new String[2][1];
            winners[0][0] = g.simBO7().getTeam_name();
        }
        else {
            winners = new String[2][(int)(Math.pow(2, 4-round-1))];
            for (int i = 0; i < matchups.size(); i++) {
                Game g = new Game(matchups.get(i)[0], matchups.get(i)[1]);

                winners[i/(int)(Math.pow(2, 4-round-1))][i%((int)(Math.pow(2, 4-round-1)))] = g.simBO7().getTeam_name();
            }
            System.out.println("winners found");
        }
        
        for (String[] t : winners) {
            for (String t1 : t) {
                System.out.print(t1 + ", ");
            }
            System.out.println();
        }
        
        // update the parents with the winners
        fill_tree_index = 0;
        root = addTeamsToBracket(root, winners, false);
        
        playoffGraph.setText("");
        
        playoffGraph.setText(display(root, 0));
        System.out.println("displayed found");
    }//GEN-LAST:event_simRoundActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        try {
            String insertSQL = "INSERT INTO MOVIES(team, director, year, rating) VALUES (?,?,?,?)";
            String name = JOptionPane.showInputDialog(null, "What is the team name? The team must not already be in the league.", null);
            teams.put(name, new Team(name, null));
            team_names = teams.keySet();
            
            String[] tn_sub = new String[team_names.size()];
            int j = 0;
            for (String tn : team_names) {
                tn_sub[j++] = tn;
            }
            System.out.println(teams.keySet());

            teamList = new javax.swing.JList<>();

            teamList.setModel(new javax.swing.AbstractListModel<String>() {
                String[] strings = tn_sub;
                public int getSize() { return strings.length; }
                public String getElementAt(int i) { return strings[i]; }
            });

            jScrollPane1.setViewportView(teamList);
            
            PreparedStatement pstmt = conn.prepareStatement(insertSQL);
            pstmt.setString(1, name);
            for (int i = 2; i < 22; i++)
                pstmt.setDouble(2,0);
            pstmt.executeUpdate();
        } catch (SQLException e) {
        
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void findMatchups(TreeNode<Team> root, int req_depth, int depth) {
        if (depth != req_depth) {
            findMatchups(root.right, req_depth, depth+1);
            findMatchups(root.left, req_depth, depth+1);
        } else {
            ArrayList<Team> to_add = new ArrayList<Team>();
            Team[] to_add2 = new Team[2];
            to_add2[0] = root.getLeft().getValue();
            to_add2[1] = root.getRight().getValue();
            matchups.add(to_add2);
        }
    }
    
    private TreeNode addTeamsToBracket(TreeNode root, String[][] pt, boolean seeded) {
        if (root.left == null || root.left.value != null) {
            if (seeded)
                root.value = teams.get(pt[fill_tree_index/(int)(Math.pow(2, 4-round-1))][seeds[fill_tree_index%(int)(Math.pow(2, 4-round-1))]-1]);
            else {
                if ((int)(Math.pow(2, 4-round-1)) != 0)
                    root.value = teams.get(pt[fill_tree_index/(int)(Math.pow(2, 4-round-1))][fill_tree_index%(int)(Math.pow(2, 4-round-1))]);
                else root.value = teams.get(pt[0][0]);
            }
            fill_tree_index++;
        } else {
            addTeamsToBracket(root.right, pt, seeded);
            addTeamsToBracket(root.left, pt, seeded);
        }
        return root;
    }
    
    private TreeNode genNullTree(TreeNode root, TreeNode parent) {
        if (root == null) {
            root = new TreeNode(null);
            root.parent = parent;
        }
        if (depth(root) < 5) {
            root.left = genNullTree(null, root);
            root.right = genNullTree(null, root);
        }
        return root;
    }
    
    private int depth(TreeNode root) {
        if (root.parent == null) return 1;
        else return 1+depth(root.parent);
    }
    
    public String display(TreeNode root) {
        return display(root, 0);
    }
        
    private String display(TreeNode t, int level) //recursive helper method
   {
       // turn your head towards left shoulder visualize tree
      String toRet = "";
      if(t == null)
         return "";
      toRet += display(t.right, level + 1); //recurse right
      for(int k = 0; k < (4-level); k++)
         toRet += "\t";
      toRet += t.value + "\n";
      toRet += display(t.left, level + 1); //recurse left
      return toRet;
   }
    
    private void sort(double[] arr) {
        int n = arr.length;
 
        // Build heap (rearrange array)
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);
 
        // One by one extract an element from heap
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            double temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
 
            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }
    
    void heapify (double[] arr, int n, int i) {
        int largest = i; // Initialize largest as root
        int l = 2 * i + 1; // left = 2*i + 1
        int r = 2 * i + 2; // right = 2*i + 2
 
        // If left child is larger than root
        if (l < n && arr[l] > arr[largest])
            largest = l;
 
        // If right child is larger than largest so far
        if (r < n && arr[r] > arr[largest])
            largest = r;
 
        // If largest is not root
        if (largest != i) {
            double swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;
 
            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }
    
    private double[] reverse(double[] arr, int n) {
        double[] b = new double[n];
        int j = n;
        for (int i = 0; i < n; i++) {
            b[j - 1] = arr[i];
            j = j - 1;
        }
        return b;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(BBallUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(BBallUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(BBallUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BBallUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new BBallUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton clear;
    private javax.swing.JButton jButton1;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton loadTeams;
    private javax.swing.JTextArea playoffGraph;
    private javax.swing.JButton playoffPredictions;
    private javax.swing.JButton simRound;
    private javax.swing.JButton sortBy;
    private javax.swing.JList<String> teamList;
    // End of variables declaration//GEN-END:variables
}
